{
  "name": "nedb",
  "version": "0.10.5",
  "author": {
    "name": "Louis Chatriot",
    "email": "louis.chatriot@gmail.com"
  },
  "contributors": [
    {
      "name": "Louis Chatriot"
    }
  ],
  "description": "File-based embedded data store for node.js",
  "keywords": [
    "database",
    "datastore",
    "embedded"
  ],
  "homepage": "https://github.com/louischatriot/nedb",
  "repository": {
    "type": "git",
    "url": "git@github.com:louischatriot/nedb.git"
  },
  "dependencies": {
    "async": "0.2.10",
    "underscore": "~1.4.4",
    "binary-search-tree": "0.2.3",
    "mkdirp": "~0.3.5"
  },
  "devDependencies": {
    "chai": "1.0.x",
    "mocha": "1.4.x",
    "request": "2.9.x",
    "sinon": "1.3.x",
    "exec-time": "0.0.2",
    "commander": "1.1.1"
  },
  "scripts": {
    "test": "./node_modules/.bin/mocha --reporter spec --timeout 2000"
  },
  "browser": {
    "./lib/customUtils.js": "./browser-version/browser-specific/lib/customUtils.js",
    "./lib/persistence.js": "./browser-version/browser-specific/lib/persistence.js"
  },
  "main": "index",
  "licence": "MIT",
  "readme": "# NeDB (Node embedded database)\r\n\r\n<img src=\"http://i.imgur.com/GdeQBmc.png\" style=\"width: 25%; height: 25%; float: left;\">\r\n\r\n**Embedded persistent database for Node.js, written in Javascript, with no dependency** (except npm\r\nmodules of course). You can **think of it as a SQLite for Node.js projects**, which\r\ncan be used with a simple `require` statement. The API is a subset of MongoDB's. You can use it as a persistent or an in-memory only datastore.\r\n\r\nNeDB is not intended to be a replacement of large-scale databases such as MongoDB! Its goal is to provide you with a clean and easy way to query data and persist it to disk, for web applications that do not need lots of concurrent connections, for example a <a href=\"https://github.com/louischatriot/braindead-ci\" target=\"_blank\">continuous integration and deployment server</a> and desktop applications built with <a href=\"https://github.com/rogerwang/node-webkit\" target=\"_blank\">Node Webkit</a>.\r\n\r\nNeDB was benchmarked against the popular client-side database <a href=\"http://www.taffydb.com/\" target=\"_blank\">TaffyDB</a> and <a href=\"https://github.com/louischatriot/taffydb-benchmark\" target=\"_blank\">NeDB is much, much faster</a>. That's why there is now <a href=\"#browser-version\">a browser version</a>.\r\n\r\nCheck the <a href=\"https://github.com/louischatriot/nedb/wiki/Change-log\" target=\"_blank\">change log in the wiki</a> if you think nedb doesn't behave as the documentation describes! Most of the issues I get are due to non-latest version NeDBs.\r\n\r\nYou want to help out? <a href=\"#contribute\">You can contribute time or bitcoins, check out how!</a>\r\n\r\n\r\n## Installation, tests\r\nModule name on npm is `nedb`.\r\n```javascript\r\nnpm install nedb --save   // Put latest version in your package.json\r\n\r\nnpm test   // You'll need the dev dependencies to test it\r\n```\r\n\r\n## API\r\nIt's a subset of MongoDB's API (the most used operations). The current API will not change, but I will add operations as they are needed. Summary of the API:  \r\n\r\n* <a href=\"#creatingloading-a-database\">Creating/loading a database</a>\r\n* <a href=\"#compacting-the-database\">Compacting the database</a>\r\n* <a href=\"#inserting-documents\">Inserting documents</a>\r\n* <a href=\"#finding-documents\">Finding documents</a>\r\n  * <a href=\"#basic-querying\">Basic Querying</a>\r\n  * <a href=\"#operators-lt-lte-gt-gte-in-nin-ne-exists-regex\">Operators ($lt, $lte, $gt, $gte, $in, $nin, $ne, $exists, $regex)</a>\r\n  * <a href=\"#array-fields\">Array fields</a>\r\n  * <a href=\"#logical-operators-or-and-not-where\">Logical operators $or, $and, $not, $where</a>\r\n  * <a href=\"#sorting-and-paginating\">Sorting and paginating</a>\r\n* <a href=\"#counting-documents\">Counting documents</a>\r\n* <a href=\"#updating-documents\">Updating documents</a>\r\n* <a href=\"#removing-documents\">Removing documents</a>\r\n* <a href=\"#indexing\">Indexing</a>\r\n\r\n### Creating/loading a database\r\nYou can use NeDB as an in-memory only datastore or as a persistent datastore. One datastore is the equivalent of a MongoDB collection. The constructor is used as follows `new Datastore(options)` where `options` is an object with the following fields:  \r\n\r\n* `filename` (optional): path to the file where the data is persisted. If left blank, the datastore is automatically considered in-memory only. It cannot end with a `~` which is used in the temporary files NeDB uses to perform crash-safe writes\r\n* `inMemoryOnly` (optional, defaults to false): as the name implies.\r\n* `autoload` (optional, defaults to false): if used, the database will\r\n  automatically be loaded from the datafile upon creation (you don't\r\nneed to call `loadDatabase`). Any command\r\nissued before load is finished is buffered and will be executed when\r\nload is done.\r\n* `onload` (optional): if you use autoloading, this is the handler called after the `loadDatabase`. It takes one `error` argument. If you use autoloading without specifying this handler, and an error happens during load, an error will be thrown.\r\n* `nodeWebkitAppName` (optional, **DEPRECATED**): if you are using NeDB from whithin a Node Webkit app, specify its name (the same one you use in the `package.json`) in this field and the `filename` will be relative to the directory Node Webkit uses to store the rest of the application's data (local storage etc.). It works on Linux, OS X and Windows. Now that you can use `require('nw.gui').App.dataPath` in Node Webkit to get the path to the data directory for your application, you should not use this option anymore and it will be removed.\r\n\r\nIf you use a persistent datastore without the `autoload` option, you need to call `loadDatabase` manually.\r\nThis function fetches the data from datafile and prepares the database. **Don't forget it!** If you use a\r\npersistent datastore, no command (insert, find, update, remove) will be executed before `loadDatabase`\r\nis called, so make sure to call it yourself or use the `autoload`\r\noption.\r\n\r\n```javascript\r\n// Type 1: In-memory only datastore (no need to load the database)\r\nvar Datastore = require('nedb')\r\n  , db = new Datastore();\r\n\r\n\r\n// Type 2: Persistent datastore with manual loading\r\nvar Datastore = require('nedb')\r\n  , db = new Datastore({ filename: 'path/to/datafile' });\r\ndb.loadDatabase(function (err) {    // Callback is optional\r\n  // Now commands will be executed\r\n});\r\n\r\n\r\n// Type 3: Persistent datastore with automatic loading\r\nvar Datastore = require('nedb')\r\n  , db = new Datastore({ filename: 'path/to/datafile', autoload: true });\r\n// You can issue commands right away\r\n\r\n\r\n// Type 4: Persistent datastore for a Node Webkit app called 'nwtest'\r\n// For example on Linux, the datafile will be ~/.config/nwtest/nedb-data/something.db\r\nvar Datastore = require('nedb')\r\n  , path = require('path')\r\n  , db = new Datastore({ filename: path.join(require('nw.gui').App.dataPath, 'something.db') });\r\n\r\n\r\n// Of course you can create multiple datastores if you need several\r\n// collections. In this case it's usually a good idea to use autoload for all collections.\r\ndb = {};\r\ndb.users = new Datastore('path/to/users.db');\r\ndb.robots = new Datastore('path/to/robots.db');\r\n\r\n// You need to load each database (here we do it asynchronously)\r\ndb.users.loadDatabase();\r\ndb.robots.loadDatabase();\r\n```\r\n\r\n### Compacting the database\r\nUnder the hood, NeDB's persistence uses an append-only format, meaning that all updates and deletes actually result in lines added at the end of the datafile. The reason for this is that disk space is very cheap and appends are much faster than rewrites since they don't do a seek. The database is automatically compacted (i.e. put back in the one-line-per-document format) everytime your application restarts.\r\n\r\nYou can manually call the compaction function with `yourDatabase.persistence.compactDatafile` which takes no argument. It queues a compaction of the datafile in the executor, to be executed sequentially after all pending operations.\r\n\r\nYou can also set automatic compaction at regular intervals with `yourDatabase.persistence.setAutocompactionInterval(interval)`, `interval` in milliseconds (a minimum of 5s is enforced), and stop automatic compaction with `yourDatabase.persistence.stopAutocompaction()`.\r\n\r\nKeep in mind that compaction takes a bit of time (not too much: 130ms for 50k records on my slow machine) and no other operation can happen when it does, so most projects actually don't need to use it.\r\n\r\n\r\n### Inserting documents\r\nThe native types are `String`, `Number`, `Boolean`, `Date` and `null`. You can also use\r\narrays and subdocuments (objects). If a field is `undefined`, it will not be saved (this is different from \r\nMongoDB which transforms `undefined` in `null`, something I find counter-intuitive).  \r\n\r\nAn `_id` field will be automatically generated by NeDB. It's a 16-characters alphanumerical string that cannot be modified once it has been generated. Unlike with MongoDB, you cannot specify it (that shouldn't be a problem anyway).\r\n\r\nField names cannot begin by '$' or contain a '.'.\r\n\r\n```javascript\r\nvar doc = { hello: 'world'\r\n               , n: 5\r\n               , today: new Date()\r\n               , nedbIsAwesome: true\r\n               , notthere: null\r\n               , notToBeSaved: undefined  // Will not be saved\r\n               , fruits: [ 'apple', 'orange', 'pear' ]\r\n               , infos: { name: 'nedb' }\r\n               };\r\n\r\ndb.insert(doc, function (err, newDoc) {   // Callback is optional\r\n  // newDoc is the newly inserted document, including its _id\r\n  // newDoc has no key called notToBeSaved since its value was undefined\r\n});\r\n```\r\n\r\nYou can also bulk-insert an array of documents. This operation is atomic, meaning that if one insert fails due to a unique constraint being violated, all changes are rolled back.\r\n```javascript\r\ndb.insert([{ a: 5 }, { a: 42 }], function (err, newDocs) {\r\n  // Two documents were inserted in the database\r\n  // newDocs is an array with these documents, augmented with their _id\r\n});\r\n\r\n// If there is a unique constraint on field 'a', this will fail\r\ndb.insert([{ a: 5 }, { a: 42 }, { a: 5 }], function (err) {\r\n  // err is a 'uniqueViolated' error\r\n  // The database was not modified\r\n});\r\n```\r\n\r\n### Finding documents\r\nUse `find` to look for multiple documents matching you query, or `findOne` to look for one specific document. You can select documents based on field equality or use comparison operators (`$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$nin`, `$ne`). You can also use logical operators `$or`, `$and`, `$not` and `$where`. See below for the syntax.\r\n\r\nYou can use regular expressions in two ways: in basic querying in place of a string, or with the `$regex` operator.\r\n\r\nYou can sort and paginate results using the cursor API (see below).\r\n\r\n#### Basic querying\r\nBasic querying means are looking for documents whose fields match the ones you specify. You can use regular expression to match strings.\r\nYou can use the dot notation to navigate inside nested documents, arrays, arrays of subdocuments and to match a specific element of an array.\r\n\r\n```javascript\r\n// Let's say our datastore contains the following collection\r\n// { _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false, satellites: ['Phobos', 'Deimos'] }\r\n// { _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true, humans: { genders: 2, eyes: true } }\r\n// { _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false }\r\n// { _id: 'id4', planet: 'Omicron Persei 8', system: 'futurama', inhabited: true, humans: { genders: 7 } }\r\n// { _id: 'id5', completeData: { planets: [ { name: 'Earth', number: 3 }, { name: 'Mars', number: 2 }, { name: 'Pluton', number: 9 } ] } }\r\n\r\n// Finding all planets in the solar system\r\ndb.find({ system: 'solar' }, function (err, docs) {\r\n  // docs is an array containing documents Mars, Earth, Jupiter\r\n  // If no document is found, docs is equal to []\r\n});\r\n\r\n// Finding all planets whose name contain the substring 'ar' using a regular expression\r\ndb.find({ planet: /ar/ }, function (err, docs) {\r\n  // docs contains Mars and Earth\r\n});\r\n\r\n// Finding all inhabited planets in the solar system\r\ndb.find({ system: 'solar', inhabited: true }, function (err, docs) {\r\n  // docs is an array containing document Earth only\r\n});\r\n\r\n// Use the dot-notation to match fields in subdocuments\r\ndb.find({ \"humans.genders\": 2 }, function (err, docs) {\r\n  // docs contains Earth\r\n});\r\n\r\n// Use the dot-notation to navigate arrays of subdocuments\r\ndb.find({ \"completeData.planets.name\": \"Mars\" }, function (err, docs) {\r\n  // docs contains document 5\r\n});\r\n\r\ndb.find({ \"completeData.planets.name\": \"Jupiter\" }, function (err, docs) {\r\n  // docs is empty\r\n});\r\n\r\ndb.find({ \"completeData.planets.0.name\": \"Earth\" }, function (err, docs) {\r\n  // docs contains document 5\r\n  // If we had tested against \"Mars\" docs would be empty because we are matching against a specific array element\r\n});\r\n\r\n\r\n// You can also deep-compare objects. Don't confuse this with dot-notation!\r\ndb.find({ humans: { genders: 2 } }, function (err, docs) {\r\n  // docs is empty, because { genders: 2 } is not equal to { genders: 2, eyes: true }\r\n});\r\n\r\n// Find all documents in the collection\r\ndb.find({}, function (err, docs) {\r\n});\r\n\r\n// The same rules apply when you want to only find one document\r\ndb.findOne({ _id: 'id1' }, function (err, doc) {\r\n  // doc is the document Mars\r\n  // If no document is found, doc is null\r\n});\r\n```\r\n\r\n#### Operators ($lt, $lte, $gt, $gte, $in, $nin, $ne, $exists, $regex)\r\nThe syntax is `{ field: { $op: value } }` where `$op` is any comparison operator:  \r\n\r\n* `$lt`, `$lte`: less than, less than or equal\r\n* `$gt`, `$gte`: greater than, greater than or equal\r\n* `$in`: member of. `value` must be an array of values\r\n* `$ne`, `$nin`: not equal, not a member of\r\n* `$exists`: checks whether the document posses the property `field`. `value` should be true or false\r\n* `$regex`: checks whether a string is matched by the regular expression. Contrary to MongoDB, the use of `$options` with `$regex` is not supported, because it doesn't give you more power than regex flags. Basic queries are more readable so only use the `$regex` operator when you need to use another operator with it (see example below)\r\n\r\n```javascript\r\n// $lt, $lte, $gt and $gte work on numbers and strings\r\ndb.find({ \"humans.genders\": { $gt: 5 } }, function (err, docs) {\r\n  // docs contains Omicron Persei 8, whose humans have more than 5 genders (7).\r\n});\r\n\r\n// When used with strings, lexicographical order is used\r\ndb.find({ planet: { $gt: 'Mercury' }}, function (err, docs) {\r\n  // docs contains Omicron Persei 8\r\n})\r\n\r\n// Using $in. $nin is used in the same way\r\ndb.find({ planet: { $in: ['Earth', 'Jupiter'] }}, function (err, docs) {\r\n  // docs contains Earth and Jupiter\r\n});\r\n\r\n// Using $exists\r\ndb.find({ satellites: { $exists: true } }, function (err, docs) {\r\n  // docs contains only Mars\r\n});\r\n\r\n// Using $regex with another operator\r\ndb.find({ planet: { $regex: /ar/, $nin: ['Jupiter', 'Earth'] } }, function (err, docs) {\r\n  // docs only contains Mars because Earth was excluded from the match by $nin\r\n});\r\n```\r\n\r\n#### Array fields\r\nWhen a field in a document is an array, NeDB first tries to see if there is an array-specific comparison function (for now there is only `$size`) being used\r\nand tries it first. If there isn't, the query is treated as a query on every element and there is a match if at least one element matches.\r\n\r\n```javascript\r\n// Using an array-specific comparison function\r\n// Note: you can't use nested comparison functions, e.g. { $size: { $lt: 5 } } will throw an error\r\ndb.find({ satellites: { $size: 2 } }, function (err, docs) {\r\n  // docs contains Mars\r\n});\r\n\r\ndb.find({ satellites: { $size: 1 } }, function (err, docs) {\r\n  // docs is empty\r\n});\r\n\r\n// If a document's field is an array, matching it means matching any element of the array\r\ndb.find({ satellites: 'Phobos' }, function (err, docs) {\r\n  // docs contains Mars. Result would have been the same if query had been { satellites: 'Deimos' }\r\n});\r\n\r\n// This also works for queries that use comparison operators\r\ndb.find({ satellites: { $lt: 'Amos' } }, function (err, docs) {\r\n  // docs is empty since Phobos and Deimos are after Amos in lexicographical order\r\n});\r\n\r\n// This also works with the $in and $nin operator\r\ndb.find({ satellites: { $in: ['Moon', 'Deimos'] } }, function (err, docs) {\r\n  // docs contains Mars (the Earth document is not complete!)\r\n});\r\n```\r\n\r\n#### Logical operators $or, $and, $not, $where\r\nYou can combine queries using logical operators:  \r\n\r\n* For `$or` and `$and`, the syntax is `{ $op: [query1, query2, ...] }`.\r\n* For `$not`, the syntax is `{ $not: query }`\r\n* For `$where`, the syntax is `{ $where: function () { /* object is \"this\", return a boolean */ } }`\r\n\r\n```javascript\r\ndb.find({ $or: [{ planet: 'Earth' }, { planet: 'Mars' }] }, function (err, docs) {\r\n  // docs contains Earth and Mars\r\n});\r\n\r\ndb.find({ $not: { planet: 'Earth' } }, function (err, docs) {\r\n  // docs contains Mars, Jupiter, Omicron Persei 8\r\n});\r\n\r\ndb.find({ $where: function () { return Object.keys(this) > 6; } }, function (err, docs) {\r\n  // docs with more than 6 properties\r\n});\r\n\r\n// You can mix normal queries, comparison queries and logical operators\r\ndb.find({ $or: [{ planet: 'Earth' }, { planet: 'Mars' }], inhabited: true }, function (err, docs) {\r\n  // docs contains Earth\r\n});\r\n\r\n```\r\n\r\n#### Sorting and paginating\r\nIf you don't specify a callback to `find`, `findOne` or `count`, a `Cursor` object is returned. You can modify the cursor with `sort`, `skip` and `limit` and then execute it with `exec(callback)`.\r\n\r\n```javascript\r\n// Let's say the database contains these 4 documents\r\n// doc1 = { _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false, satellites: ['Phobos', 'Deimos'] }\r\n// doc2 = { _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true, humans: { genders: 2, eyes: true } }\r\n// doc3 = { _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false }\r\n// doc4 = { _id: 'id4', planet: 'Omicron Persei 8', system: 'futurama', inhabited: true, humans: { genders: 7 } }\r\n\r\n// No query used means all results are returned (before the Cursor modifiers)\r\ndb.find({}).sort({ planet: 1 }).skip(1).limit(2).exec(function (err, docs) {\r\n  // docs is [doc3, doc1]\r\n});\r\n\r\n// You can sort in reverse order like this\r\ndb.find({ system: 'solar' }).sort({ planet: -1 }).exec(function (err, docs) {\r\n  // docs is [doc1, doc3, doc2]\r\n});\r\n\r\n// You can sort on one field, then another, and so on like this:\r\ndb.find({}).sort({ firstField: 1, secondField: -1 }) ...   // You understand how this works!\r\n```\r\n\r\n\r\n\r\n### Counting documents\r\nYou can use `count` to count documents. It has the same syntax as `find`. For example:\r\n\r\n```javascript\r\n// Count all planets in the solar system\r\ndb.count({ system: 'solar' }, function (err, count) {\r\n  // count equals to 3\r\n});\r\n\r\n// Count all documents in the datastore\r\ndb.count({}, function (err, count) {\r\n  // count equals to 4\r\n});\r\n```\r\n\r\n\r\n### Updating documents\r\n`db.update(query, update, options, callback)` will update all documents matching `query` according to the `update` rules:  \r\n* `query` is the same kind of finding query you use with `find` and `findOne`\r\n* `update` specifies how the documents should be modified. It is either a new document or a set of modifiers (you cannot use both together, it doesn't make sense!)\r\n  * A new document will replace the matched docs\r\n  * The modifiers create the fields they need to modify if they don't exist, and you can apply them to subdocs. Available field modifiers are `$set` to change a field's value, `$unset` to delete a field and `$inc` to increment a field's value. To work on arrays, you have `$push`, `$pop`, `$addToSet`, `$pull`, and the special `$each`. See examples below for the syntax.\r\n* `options` is an object with two possible parameters\r\n  * `multi` (defaults to `false`) which allows the modification of several documents if set to true\r\n  * `upsert` (defaults to `false`) if you want to insert a new document corresponding to the `update` rules if your `query` doesn't match anything\r\n* `callback` (optional) signature: `err`, `numReplaced`, `newDoc`\r\n  * `numReplaced` is the number of documents replaced\r\n  * `newDoc` is the created document if the upsert mode was chosen and a document was inserted\r\n\r\n**Note**: you can't change a document's _id.\r\n\r\n```javascript\r\n// Let's use the same example collection as in the \"finding document\" part\r\n// { _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false }\r\n// { _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true }\r\n// { _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false }\r\n// { _id: 'id4', planet: 'Omicron Persia 8', system: 'futurama', inhabited: true }\r\n\r\n// Replace a document by another\r\ndb.update({ planet: 'Jupiter' }, { planet: 'Pluton'}, {}, function (err, numReplaced) {\r\n  // numReplaced = 1\r\n  // The doc #3 has been replaced by { _id: 'id3', planet: 'Pluton' }\r\n  // Note that the _id is kept unchanged, and the document has been replaced\r\n  // (the 'system' and inhabited fields are not here anymore)\r\n});\r\n\r\n// Set an existing field's value\r\ndb.update({ system: 'solar' }, { $set: { system: 'solar system' } }, { multi: true }, function (err, numReplaced) {\r\n  // numReplaced = 3\r\n  // Field 'system' on Mars, Earth, Jupiter now has value 'solar system'\r\n});\r\n\r\n// Setting the value of a non-existing field in a subdocument by using the dot-notation\r\ndb.update({ planet: 'Mars' }, { $set: { \"data.satellites\": 2, \"data.red\": true } }, {}, function () {\r\n  // Mars document now is { _id: 'id1', system: 'solar', inhabited: false\r\n  //                      , data: { satellites: 2, red: true }\r\n  //                      }\r\n  // Not that to set fields in subdocuments, you HAVE to use dot-notation\r\n  // Using object-notation will just replace the top-level field\r\n  db.update({ planet: 'Mars' }, { $set: { data: { satellites: 3 } } }, {}, function () {\r\n    // Mars document now is { _id: 'id1', system: 'solar', inhabited: false\r\n    //                      , data: { satellites: 3 }\r\n    //                      }\r\n    // You lost the \"data.red\" field which is probably not the intended behavior\r\n  });\r\n});\r\n\r\n// Deleting a field\r\ndb.update({ planet: 'Mars' }, { $unset: { planet: true } }, {}, function () {\r\n  // Now the document for Mars doesn't contain the planet field\r\n  // You can unset nested fields with the dot notation of course\r\n});\r\n\r\n// Upserting a document\r\ndb.update({ planet: 'Pluton' }, { planet: 'Pluton', inhabited: false }, { upsert: true }, function (err, numReplaced, upsert) {\r\n  // numReplaced = 1, upsert = { _id: 'id5', planet: 'Pluton', inhabited: false }\r\n  // A new document { _id: 'id5', planet: 'Pluton', inhabited: false } has been added to the collection\r\n});\r\n\r\n// If you upsert with a modifier, the upserted doc is the query modified by the modifier\r\n// This is simpler than it sounds :)\r\ndb.update({ planet: 'Pluton' }, { $inc: { distance: 38 } }, { upsert: true }, function () {\r\n  // A new document { _id: 'id5', planet: 'Pluton', distance: 38 } has been added to the collection  \r\n});\r\n\r\n// If we insert a new document { _id: 'id6', fruits: ['apple', 'orange', 'pear'] } in the collection,\r\n// let's see how we can modify the array field atomically\r\n\r\n// $push inserts new elements at the end of the array\r\ndb.update({ _id: 'id6' }, { $push: { fruits: 'banana' } }, {}, function () {\r\n  // Now the fruits array is ['apple', 'orange', 'pear', 'banana']\r\n});\r\n\r\n// $pop removes an element from the end (if used with 1) or the front (if used with -1) of the array\r\ndb.update({ _id: 'id6' }, { $pop: { fruits: 1 } }, {}, function () {\r\n  // Now the fruits array is ['apple', 'orange']\r\n  // With { $pop: { fruits: -1 } }, it would have been ['orange', 'pear']\r\n});\r\n\r\n// $addToSet adds an element to an array only if it isn't already in it\r\n// Equality is deep-checked (i.e. $addToSet will not insert an object in an array already containing the same object)\r\n// Note that it doesn't check whether the array contained duplicates before or not\r\ndb.update({ _id: 'id6' }, { $addToSet: { fruits: 'apple' } }, {}, function () {\r\n  // The fruits array didn't change\r\n  // If we had used a fruit not in the array, e.g. 'banana', it would have been added to the array\r\n});\r\n\r\n// $pull removes all values matching a value or even any NeDB query from the array\r\ndb.update({ _id: 'id6' }, { $pull: { fruits: 'apple' } }, {}, function () {\r\n  // Now the fruits array is ['orange', 'pear']\r\n});\r\ndb.update({ _id: 'id6' }, { $pull: { fruits: $in: ['apple', 'pear'] } }, {}, function () {\r\n  // Now the fruits array is ['orange']\r\n});\r\n\r\n\r\n\r\n// $each can be used to $push or $addToSet multiple values at once\r\n// This example works the same way with $addToSet\r\ndb.update({ _id: 'id6' }, { $push: { fruits: ['banana', 'orange'] } }, {}, function () {\r\n  // Now the fruits array is ['apple', 'orange', 'pear', 'banana', 'orange']\r\n});\r\n```\r\n\r\n### Removing documents\r\n`db.remove(query, options, callback)` will remove all documents matching `query` according to `options`  \r\n* `query` is the same as the ones used for finding and updating\r\n* `options` only one option for now: `multi` which allows the removal of multiple documents if set to true. Default is false\r\n* `callback` is optional, signature: err, numRemoved\r\n\r\n```javascript\r\n// Let's use the same example collection as in the \"finding document\" part\r\n// { _id: 'id1', planet: 'Mars', system: 'solar', inhabited: false }\r\n// { _id: 'id2', planet: 'Earth', system: 'solar', inhabited: true }\r\n// { _id: 'id3', planet: 'Jupiter', system: 'solar', inhabited: false }\r\n// { _id: 'id4', planet: 'Omicron Persia 8', system: 'futurama', inhabited: true }\r\n\r\n// Remove one document from the collection\r\n// options set to {} since the default for multi is false\r\ndb.remove({ _id: 'id2' }, {}, function (err, numRemoved) {\r\n  // numRemoved = 1\r\n});\r\n\r\n// Remove multiple documents\r\ndb.remove({ system: 'solar' }, { multi: true }, function (err, numRemoved) {\r\n  // numRemoved = 3\r\n  // All planets from the solar system were removed\r\n});\r\n```\r\n\r\n### Indexing\r\nNeDB supports indexing. It gives a very nice speed boost and can be used to enforce a unique constraint on a field. You can index any field, including fields in nested documents using the dot notation. For now, indexes are only used to speed up basic queries and queries using `$in`, `$lt`, `$lte`, `$gt` and `$gte`.\r\n\r\nTo create an index, use `datastore.ensureIndex(options, cb)`, where callback is optional and get passed an error if any (usually a unique constraint that was violated). `ensureIndex` can be called when you want, even after some data was inserted, though it's best to call it at application startup. The options are:  \r\n\r\n* **fieldName** (required): name of the field to index. Use the dot notation to index a field in a nested document.\r\n* **unique** (optional, defaults to `false`): enforce field uniqueness. Note that a unique index will raise an error if you try to index two documents for which the field is not defined.\r\n* **sparse** (optional, defaults to `false`): don't index documents for which the field is not defined. Use this option along with \"unique\" if you want to accept multiple documents for which it is not defined.\r\n\r\nNote: the `_id` is automatically indexed with a unique constraint, no need to call `ensureIndex` on it.\r\n\r\nYou can remove a previously created index with `datastore.removeIndex(fieldName, cb)`.\r\n\r\nIf your datastore is persistent, the indexes you created are persisted in the datafile, when you load the database a second time they are automatically created for you. No need to remove any `ensureIndex` though, if it is called on a database that already has the index, nothing happens.\r\n\r\n```javascript\r\ndb.ensureIndex({ fieldName: 'somefield' }, function (err) {\r\n  // If there was an error, err is not null\r\n});\r\n\r\n// Using a unique constraint with the index\r\ndb.ensureIndex({ fieldName: 'somefield', unique: true }, function (err) {\r\n});\r\n\r\n// Using a sparse unique index\r\ndb.ensureIndex({ fieldName: 'somefield', unique: true, sparse: true }, function (err) {\r\n});\r\n\r\n\r\n// Format of the error message when the unique constraint is not met\r\ndb.insert({ somefield: 'nedb' }, function (err) {\r\n  // err is null\r\n  db.insert({ somefield: 'nedb' }, function (err) {\r\n    // err is { errorType: 'uniqueViolated'\r\n    //        , key: 'name'\r\n    //        , message: 'Unique constraint violated for key name' }\r\n  });\r\n});\r\n\r\n// Remove index on field somefield\r\ndb.removeIndex('somefield', function (err) {\r\n});\r\n```\r\n\r\n**Note:** the `ensureIndex` function creates the index synchronously, so it's best to use it at application startup. It's quite fast so it doesn't increase startup time much (35 ms for a collection containing 10,000 documents).\r\n\r\n\r\n## Browser version\r\nAs of v0.8.0, you can use NeDB in the browser! You can find it and its minified version in the repository, in the `browser-version/out` directory. You only need to require `nedb.js` or `nedb.min.js` in your HTML file and the global object `Nedb` can be used right away, with the same API as the server version:\r\n\r\n```\r\n<script src=\"nedb.min.js\"></script>\r\n<script>\r\n  var db = new Nedb();   // Create an in-memory only datastore\r\n  \r\n  db.insert({ planet: 'Earth' });\r\n  db.insert({ planet: 'Mars' });\r\n\r\n  db.find({}, function (err, docs) {\r\n    // docs contains the two planets Earth and Mars\r\n  });\r\n</script>\r\n```\r\n\r\nIt has been tested and is compatible with Chrome, Safari, Firefox, IE 10, IE 9. Please open an issue if you need compatibility with IE 8/IE 7, I think it will need some work and am not sure it is needed, since most complex webapplications - the ones that would need NeDB - only work on modern browsers. To launch the tests, simply open the file `browser-version/test/index.html` in a browser and you'll see the results of the tests for this browser.\r\n\r\nIf you fork and modify nedb, you can build the browser version from the sources, the build script is `browser-version/build.js`.\r\n\r\n**The browser version is still young!** For now you can only use it as an in-memory database in browser environments, I'll implement persistence later.\r\n\r\n\r\n## Performance\r\n### Speed\r\nNeDB is not intended to be a replacement of large-scale databases such as MongoDB, and as such was not designed for speed. That said, it is still pretty fast on the expected datasets, especially if you use indexing. On my machine (3 years old, no SSD), with a collection containing 10,000 documents, with indexing:  \r\n* Insert: **5,950 ops/s**\r\n* Find: **25,440 ops/s**\r\n* Update: **4,490 ops/s**\r\n* Remove: **6,620 ops/s**  \r\n\r\nYou can run the simple benchmarks I use by executing the scripts in the `benchmarks` folder. Run them with the `--help` flag to see how they work.\r\n\r\n### Memory footprint\r\nA copy of the whole database is kept in memory. This is not much on the\r\nexpected kind of datasets (20MB for 10,000 2KB documents). If requested, I'll introduce an\r\noption to not use this cache to decrease memory footprint (at the cost\r\nof a lower speed).\r\n\r\n\r\n## Use in other services\r\n* <a href=\"https://github.com/louischatriot/connect-nedb-session\"\r\n  target=\"_blank\">connect-nedb-session</a> is a session store for\r\nConnect and Express, backed by nedb\r\n* If you mostly use NeDB for logging purposes and don't want the memory footprint of your application to grow too large, you can use <a href=\"https://github.com/louischatriot/nedb-logger\" target=\"_blank\">NeDB Logger</a> to insert documents in a NeDB-readable database\r\n* If you've outgrown NeDB, switching to MongoDB won't be too hard as it is the same API. Use <a href=\"https://github.com/louischatriot/nedb-to-mongodb\" target=\"_blank\">this utility</a> to transfer the data from a NeDB database to a MongoDB collection\r\n\r\n\r\n## Contribute!\r\nYou want to help? You can contribute time or bitcoins.\r\n\r\n### Helping on the codebase\r\nIssues reporting and pull requests are always appreciated. For issues, make sure to always include a code snippet and describe the expected vs actual behavior. If you send a pull request, make sure to stick to NeDB's coding style and always test all the code you submit. You can look at the current tests to see how to do it\r\n\r\n### Bitcoins\r\nYou don't have time? You can support NeDB by sending bitcoins to this adress: 1dDZLnWpBbodPiN8sizzYrgaz5iahFyb1\r\n\r\n\r\n## License \r\n\r\n(The MIT License)\r\n\r\nCopyright (c) 2013 Louis Chatriot &lt;louis.chatriot@gmail.com&gt;\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n'Software'), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/louischatriot/nedb/issues"
  },
  "_id": "nedb@0.10.5",
  "_from": "nedb@0.10.5"
}
